<script lang="ts">
	import { cn } from '$lib/utils';
	import { getContext, onMount, type Snippet } from 'svelte';
	import { applyOffset } from './fns/apply-offset';
	import LoadingIndicator from './loading-indicator.svelte';
	import { STAY_IN_PLACE } from './CONSTSANTS';
	import Row from './row.svelte';
	import StateIndicator from './state-indicator.svelte';
	import ScrollToTopButton from './scroll-to-top-button.svelte';
	import Pagination from './shadcn/pagination.svelte';
	import LoadingIndicatorContainer from './loading-indicator-container.svelte';
	import type { TzezarDatagrid } from './tzezar-datagrid.svelte';
	import { paginateData } from './fns/paginate-data';
	import { sortData } from './fns/sort-data';
	import { filterData } from './fns/filter-data';
	import TopBar from './top-bar.svelte';

	// TODO: this component grew big, need to split it into smaller components
	let datagrid = getContext<TzezarDatagrid<unknown>>('datagrid');

	type Props = {
		head?: Snippet;
		loadingIndicator?: Snippet;
		dataIndicator?: Snippet;
		body?: Snippet;
		topBar?: Snippet;
		footer?: Snippet;
		class?: {
			wrapper?: string;
			table?: string;
		};
		pagination?: Snippet;
	};

	let {
		pagination,
		topBar,
		body,
		loadingIndicator,
		dataIndicator,
		head,
		footer,
		class: _class = {
			wrapper: '',
			table: ''
		}
	}: Props = $props();

	onMount(() => {
		if (datagrid.columns.some((column) => column.pinned)) {
			applyOffset(datagrid.columns);
		}
	});

	// ! BUG for some reason internal logic, like sorting, filtering and pagination runs after render
	// ! in theory data is not changing but in practice it is for unknown reason
	// ! whole chain of logic comes from filterDate() that takes data as parameter
	// ! maybe move that logic to another place? instead of $effect make it inside class as $derrived

	// ? Worth noting the order. On small samples of data, it doesn't change anything but on large ones,
	// ? it is better to filter first and then sort because the best sorting algorithms are O(n log n) so the less data you have,
	// ? the faster it is, and filtering shrinks the size of the sample, so filtering first is faster.
	$effect(() => {
		if (datagrid.mode === 'client') {
			datagrid.internal.filteredData = filterData([...datagrid.data], datagrid.state.filters);
		}
	});

	$effect(() => {
		if (datagrid.mode === 'client') {
			datagrid.internal.sortedData = sortData(
				[...datagrid.internal.filteredData],
				datagrid.state.sortingArray
			);
		}
	});

	$effect(() => {
		if (datagrid.mode === 'client') {
			datagrid.internal.paginatedData = paginateData(
				datagrid.internal.sortedData,
				datagrid.state.pagination.page,
				datagrid.state.pagination.perPage
			);
		}
	});

	$effect(() => {
		if (datagrid.mode === 'client') {
			datagrid.state.pagination.count = datagrid.internal.filteredData.length || 1;
		}
	});

	let end: HTMLElement;
	$effect.pre(() => {
		// TODO: this has to be refactored
		// * there must be easier way to do this
		// ? maybe add display fixed instead of absolute and disable scrolling
		// datagrid in fullscreen mode appear on top of the page, so we need to scroll it to the top
		if (datagrid.state.isFullscreenActive) {
			document.body.classList.add('overflow-hidden');
			document.body.scrollIntoView({ behavior: 'smooth', block: 'start' });
		} else {
			// if datagrid is not in fullscreen mode, we need to scroll back to it's original position
			if (!end) {
				document.body.classList.remove('overflow-hidden');
				return;
			}
			end.scrollIntoView({ behavior: 'smooth', block: 'start' });
			document.body.classList.remove('overflow-hidden');
		}
	});
</script>

<!-- WRAPPER -->
<div
	class={cn(
		'flex flex-col ',
		datagrid.state.isFullscreenActive && 'absolute inset-0 z-[20] bg-primary-foreground  p-4'
	)}
	style="font-size: {datagrid.options.fontSize.selected.value};"
>
	{#if datagrid.options.topbar.display}
		{#if topBar}
			{@render topBar()}
		{:else}
			<TopBar />
		{/if}
	{/if}
	<!-- CONTENT -->
	<div
		data-datagrid={datagrid.identifier}
		class={cn(
			'relative flex flex-col border',
			datagrid.options.scrollable ? 'max-h-[70vh]  overflow-auto ' : ''
		)}
	>
		<!-- HEAD -->
		<div class="w sticky top-0 z-[16] flex min-w-fit" data-datagrid-head={datagrid.identifier}>
			{#if head}
				{@render head()}
			{/if}
		</div>
		<!-- LOADING INDICATOR -->
		{#if datagrid.options.statusIndicator.display}
			{#if loadingIndicator}
				{@render loadingIndicator()}
			{:else}
				<LoadingIndicatorContainer>
					<LoadingIndicator
						isError={datagrid.state.status.isError}
						isFetching={datagrid.state.status.isFetching}
						isRefetching={datagrid.state.status.isRefetching}
					/>
				</LoadingIndicatorContainer>
			{/if}
		{/if}
		<!-- DATA INDICATOR -->
		{#if datagrid.options.dataIndicator.display}
			{#if dataIndicator}
				{@render dataIndicator()}
			{:else}
				<Row class={`${STAY_IN_PLACE}`}>
					<StateIndicator
						isLoading={datagrid.state.status.isFetching}
						isError={datagrid.state.status.isError}
					/>
				</Row>
			{/if}
		{/if}
		<!-- BODY -->
		{#if body}
			<!-- ? BODY can not be wrapped inside html element, it break sticky and rows -->
			<!-- ? there is possibility to move other elements like header, topbar etc to ouside of parent container -->
			<!-- ? but then header and body X axis scroll have to be synced via js -->
			{@render body()}
		{/if}
		<!-- FOOTER -->
		{#if datagrid.options.footer.display}
			<Row
				class="sticky bottom-0 left-0 z-[15] flex w-full min-w-full flex-col  border-b-0 border-t bg-table-primary"
			>
				{#if footer}
					{@render footer()}
				{:else}
					<div
						class="flex items-center justify-between p-2 pl-3"
						data-datagrid-footer-identifier={datagrid.identifier}
					>
						<div class="ml-auto">
							<ScrollToTopButton />
						</div>
					</div>
				{/if}
			</Row>
		{/if}
	</div>
	<!-- PAGINATION -->
	{#if datagrid.options.pagination.display}
		{#if !pagination}
			<Pagination />
		{:else}
			{@render pagination()}
		{/if}
	{/if}
</div>
<div bind:this={end} aria-hidden="true" class="hidden"></div>
